# -*- coding: utf-8 -*-
"""Cryptocurrency_Linear_Regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15AXxvOLalPTbtWCgCXc_KQWMAO8e0Ec4
"""

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score

# load the coin data into a dataframe
def load_coin(filename):
  coin_df = pd.read_csv(filename)
  return coin_df

# split the data into 80% train set and 20% test set randomly
def split_coin_data(data, target):
  coin_traindata, coin_testdata, coin_traintarget, coin_testtarget = train_test_split(data,
                                              target,
                                              test_size = 0.2)
  return coin_traindata, coin_testdata, coin_traintarget, coin_testtarget

# train with linear regression x = sentiment score and y = price change daily
def coin_train(traindata, testdata, traintarget, testtarget):
  
  lin_model = LinearRegression()
  lin_model.fit(traindata, traintarget)
  predict = lin_model.predict(testdata)
  
  draw_graph(testdata, testtarget, predict)

  rmse = (np.sqrt(mean_squared_error(testtarget, predict)))
  r2 = r2_score(testtarget, predict)
  print('Coef = {}, Intercept = {}'.format(lin_model.coef_, lin_model.intercept_))
  print('Test RMSE = {}, Test R2 = {}'.format(rmse,r2))
  return lin_model.coef_ , lin_model.intercept_

def draw_graph(testdata, testtarget, predict):
  x = testdata['Score']
  x = x.to_numpy()
  y = testdata['volatility']
  y = y.to_numpy()
  z = testtarget
  
  fig = plt.figure(figsize=(15,5))
  ax1 = fig.add_subplot(121)
  ax1.scatter(x, z,  color = 'b')
  m, b = np.polyfit(x, predict, 1)
  ax1.plot(x, m*x+b, color = 'k')
  ax1.set_xlabel('Score')
  ax1.set_ylabel('Price difference')
  ax1.title.set_text('Sentiment Score V.S. Price Change')
  ax2 = fig.add_subplot(122)
  ax2.scatter(y, z, color = 'r')
  m, b = np.polyfit(y, predict, 1)
  ax2.plot(y, m*y+b, color = 'k')
  ax2.set_xlabel('Volatility')
  ax2.set_ylabel('Price difference')
  ax2.title.set_text('Volatility V.S. Price Change')
  plt.show()

btc_df = load_coin('BTC_train.csv')

btc_totaldata = btc_df.loc[:, ['Score', 'volatility']]
btc_totaltarget = btc_df[['open','close']]
btc_totaltarget = (btc_totaltarget.close - btc_totaltarget.open) / btc_totaltarget.open
frame = {'Price Change': btc_totaltarget}
btc_totaltarget = pd.DataFrame(frame)

btc_traindata, btc_testdata, btc_traintarget, btc_testtarget = split_coin_data(btc_totaldata, btc_totaltarget)

coin_train(btc_traindata, btc_testdata, btc_traintarget, btc_testtarget)

eth_df = load_coin('ETH_train.csv')

eth_totaldata = eth_df.loc[:, ['Score', 'volatility']]
eth_totaltarget = eth_df[['open','close']]
eth_totaltarget = (eth_totaltarget.close - eth_totaltarget.open) / eth_totaltarget.open
frame = {'Price Change': eth_totaltarget}
eth_totaltarget = pd.DataFrame(frame)

eth_traindata, eth_testdata, eth_traintarget, eth_testtarget = split_coin_data(eth_totaldata, eth_totaltarget)

coin_train(eth_traindata, eth_testdata, eth_traintarget, eth_testtarget)

doge_df = load_coin('DOGE_train.csv')

doge_totaldata = doge_df.loc[:, ['Score', 'volatility']]
doge_totaltarget = doge_df[['open','close']]
doge_totaltarget = (doge_totaltarget.close - doge_totaltarget.open) / doge_totaltarget.open
frame = {'Price Change': doge_totaltarget}
doge_totaltarget = pd.DataFrame(frame)

doge_traindata, doge_testdata, doge_traintarget, doge_testtarget = split_coin_data(doge_totaldata, doge_totaltarget)

coin_train(doge_traindata, doge_testdata, doge_traintarget, doge_testtarget)